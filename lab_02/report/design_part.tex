\chapter{Конструкторская часть}

\section{Требования к программе}

К разрабатываемому программному обеспечению предъявляется следующий набор функциональных требований:
\begin{enumerate}
    \item программное обеспечение должно предоставлять пользователю текстовый интерфейс для выбора режима работы;
    \item необходимо реализовать поддержку двух основных режимов:
        \begin{itemize}
            \item вычисление среднего значения всех элементов последовательности, заканчивающейся нулём, с ручным вводом данных;
            \item массовое тестирование для замера производительности на последовательностях различных размеров.
        \end{itemize}
    \item в ручном режиме программа должна запрашивать элементы последовательности до первого нуля и выполнять валидацию вводимых данных;
    \item в режиме массового тестирования должны выполняться замеры процессорного времени для каждого из реализованных алгоритмов. Результаты замеров следует выводить в наглядном табличном формате.
\end{enumerate}

\section{Разработка алгоритмов}

Визуальное представление логики работы алгоритмов представлено в виде блок-схем. На рисунке~\ref{fig:iter_scheme} показана схема итеративного алгоритма вычисления среднего значения элементов последовательности. Схема рекурсивного алгоритма вычисления среднего значения элементов последовательности показана на рисунке~\ref{fig:rec_scheme}.

\begin{figure}[H]
    \centerline{\includegraphics[]{images/iter_scheme}}
    \caption{Схема итеративного алгоритма вычисления среднего значения элементов последовательности}
    \label{fig:iter_scheme}
\end{figure}

\begin{figure}[H]
    \centerline{\includegraphics[width=18cm]{images/rec_scheme}}
    \caption{Схема рекурсивного алгоритма вычисления среднего значения элементов последовательности}
    \label{fig:rec_scheme}
\end{figure}
\clearpage


\section{Расчёт трудоёмкости алгоритмов}

\subsection{Модель вычислений}

Для проведения теоретической оценки трудоёмкости алгоритмов вводится следующая модель вычислений:
\begin{enumerate}
    \item стоимость базовых операций. Операции присваивания, сравнения, инкремента/декремента, простого сложения/вычитания, индексации массива, разыменования ($=, ==, !=, <, >, <=, >=, ++, --, +, -, [], *$) имеют условную стоимость, равную $1$;
    \item стоимость арифметических операций. Операции умножения, деления и взятия остатка ($\cdot, /, \%$) считаются более затратными и имеют условную стоимость, равную $2$;
    \item трудоёмкость условного оператора. Для оператора \textit{if (условие)} \{блок X\} \textit{else} \{блок Y\} общая трудоёмкость ($f_{\text{if}}$) складывается из стоимости вычисления условия ($f_{\text{условия}}$) и стоимости выполнения соответствующей ветви по формуле~\eqref{eq:if_cost}.
        \begin{equation}
            \label{eq:if_cost}
            f_{\text{if}} = f_{\text{условия}} +
            \begin{cases}
                \min(f_X, f_Y), & \text{в лучшем случае} \\
                \max(f_X, f_Y), & \text{в худшем случае}
            \end{cases}
        \end{equation}
    \item трудоёмкость цикла. Для цикла \textit{for} с $N$ итерациями общая трудоёмкость ($f_{\text{for}}$) рассчитывается как сумма стоимости инициализации ($f_{\text{init}}$), всех проверок условия ($N+1$ раз) и выполнения тела цикла и инкремента ($N$ раз) по формуле~\eqref{eq:for_cost}.
        \begin{equation}
            \label{eq:for_cost}
            f_{\text{for}} = f_{\text{init}} + (N+1) \cdot f_{\text{условия}} + N \cdot (f_{\text{тело}} + f_{\text{инкремент}})
        \end{equation}
\end{enumerate}

\subsection{Расчёт трудоёмкости итеративного алгоритма}

Трудоёмкость итеративного алгоритма рассчитывается по формуле~\eqref{eq:for_cost} и приведена в формуле~\eqref{eq:iter_comp}.

\begin{equation}
    \label{eq:iter_comp}
    f_{\text{iter}} = 1 + 1 + 2 + N \cdot (2 + 2 + 1) + 1 + 3 = 5N + 8 \approx 5N
\end{equation}

Асимптотическая сложность --- $O(N)$.

\subsection{Расчёт трудоёмкости рекурсивного алгоритма}

Трудоёмкость рекурсивного алгоритма рассчитывается по формуле~\eqref{eq:recursive_comp_book}.

\begin{equation}
    \label{eq:recursive_comp_book}
    f_A(D) = R(D) \cdot f_R(1) + R_L(D) \cdot f_\text{$CL$}(1) + R_V(D) \cdot f_\text{$CV$}(v),
\end{equation}
где:
\begin{enumerate}
    \item $R(D)$ --- это общее количество вершин дерева рекурсии для входа $D$;
    \item $f_R(1)$ --- это количество базовых операций для обслуживания одного рекурсивного вызова;
    \item $R_L(D)$ --- это количество листьев дерева рекурсии для входа $D$;
    \item $f_\text{$CL$}(1)$ --- это трудоёмкость алгоритма при останове рекурсии; 
    \item $R_V(D)$ --- это количество внутренних вершин дерева для входа $D$;
    \item $f_\text{$CV$}(v)$ --- это трудоёмкость вычислений в любой внутренней вершине.
\end{enumerate}

Для данного алгоритма количество листьев дерева рекурсии всегда равно $1$, то есть $R_L(D) = 1$. Количество внутренних вершин дерева рекурсии $R_V(D) = N - 1$. Общее количество вершин дерева рекурсии $R(D) = N$.

Трудоёмкость алгоритма при останове рекурсии приведена в формуле~\eqref{eq:end_rec}.

\begin{equation}
    \label{eq:end_rec}
    f_\text{$CL$}(1) = 2 + 2 + 5 = 9
\end{equation}

Трудоёмкость вычислений в любой внутренней вершине приведена в формуле~\eqref{eq:inner_rec}.

\begin{equation}
    \label{eq:inner_rec}
    f_\text{$CV$}(v) = 2 + 2 + 3 + 1 + 1 = 9
\end{equation}

Количество базовых операций для обслуживания одного рекурсивного вызова рассчитывается по формуле~\eqref{eq:call_rec}.

\begin{equation}
    \label{eq:call_rec}
    f_R(1) = 2 \cdot (p + k + r + f + l + 1), f = 1,
\end{equation}
где:
\begin{enumerate}
    \item $p$ --- количество передаваемых фактических параметров;
    \item $r$ --- количество сохраняемых в стеке регистров;
    \item $k$ --- количество возвращаемых по адресной ссылке значений; 
    \item $l$ --- количество локальных ячеек процедуры, сохранение которых необходимо для обеспечения реентерабельности.
\end{enumerate}

Применив формулу~\eqref{eq:call_rec} к рассматриваемому алгоритму, получается формула~\eqref{eq:call_rec_val}.

\begin{equation}
    \label{eq:call_rec_val}
    f_R(1) = 2 \cdot (1 + 0 + 2 + 1 + 1 + 1) = 2 \cdot 6 = 12
\end{equation}

Итоговая трудоёмкость выражается по формуле~\eqref{eq:total_rec_comp}.

\begin{equation}
    \label{eq:total_rec_comp}
    f_A(D) = N \cdot 12 + 1 \cdot 9 + (N - 1) \cdot 9 = 12N + 9 + 9N - 9 = 21N 
\end{equation}

Асимптотическая сложность --- $O(N)$.


\section{Оценка используемой алгоритмами памяти}

\subsection{Оценка используемой памяти для итеративного алгоритма}

Так как в итеративном алгоритме память используется только для создания трёх локальных переменных вне цикла, то использование памяти итеративным алгоритмом не зависит от входных данных и асимптотически оценивается как $O(1)$.

\subsection{Оценка используемой памяти для рекурсивного алгоритма}

Количество используемых ячеек памяти для обслуживания одного рекурсивного вызова рассчитывается по формуле~\eqref{eq:call_rec_mem}.

\begin{equation}
    \label{eq:call_rec_mem}
    V_R(1) = p + k + f + l + 1 = 1 + 2 + 1 + 1 + 1 = 6
\end{equation}

Объём используемой памяти рассчитывается по формуле~\eqref{eq:rec_mem}.

\begin{equation}
    \label{eq:rec_mem}
    V_R(D) = V_R(1) \cdot H_R(D) = 6 \cdot N = 6N,
\end{equation}
где $H_R(D) = R(D)$ --- это максимальная глубина дерева рекурсии.

Асимптотическая сложность --- $O(N)$.


\section*{Вывод}

В конструкторской части были сформулированы требования к программной реализации и представлены блок-схемы, описывающие логику работы итеративного и рекурсивного алгоритмов вычисления среднего значения последовательности. Была введена модель вычислений, на основе которой проведена теоретическая оценка и анализ трудоёмкости и затрачиваемой памяти.

Результаты анализа трудоёмкости памяти показывают, что асимптотическая сложность алгоритмов одинаковая, однако трудоёмкость рекурсивного алгоритма больше в $4.2$ раза.

Результаты оценки использования памяти показывают, что использование памяти итеративным алгоритмом асимптотически оценивается как $O(1)$, а рекурсивного оценивается как $O(N)$.
